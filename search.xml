<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[JS筆記] 函式呼叫與執行堆</title>
      <link href="/JavaScript/2019/11/24/javascript-weird-5/"/>
      <url>/JavaScript/2019/11/24/javascript-weird-5/</url>
      
        <content type="html"><![CDATA[<h3 id="函式呼叫-function-invocation"><a href="#函式呼叫-function-invocation" class="headerlink" title="函式呼叫(function invocation)"></a>函式呼叫(function invocation)</h3><blockquote><p>invocation:running a function</p></blockquote><p>它代表的意思是呼叫或執行函數，</p><p>因此當我們說function invocation代表執行了這個函式。</p><a id="more"></a><h3 id="執行堆-execution-stack"><a href="#執行堆-execution-stack" class="headerlink" title="執行堆(execution stack)"></a>執行堆(execution stack)</h3><p>接著我們用下列簡單的程式碼範例來解釋什麼是執行堆。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>上述的程式碼會先創造Global Execution Context，</p><p>並創造變數this及全域物件。</p><p>接著將函數放進記憶體中，而在創造階段函式b、a都被放入記憶體中，</p><p>第二階段開始逐行執行程式碼，</p><p>當執行了 <code>function a</code>時一個新的執行環境被創造，</p><p>且放入執行堆中並且如同創建全域執行環境的步驟一樣，</p><p><code>function a</code>的執行環境有自己的記憶體空間放變數和函式，</p><p>並設置記憶體中的位置再逐行執行。</p><img src="/JavaScript/2019/11/24/javascript-weird-5/execution-stack.png"><p>接著在函式a裡呼叫了函式b，</p><p>因此如同前面的步驟會先創造函式b的執行環境，</p><p>當函式b執行完畢之後他的執行環境就會離開，</p><p>接著會回到a的執行環境繼續執行。</p><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>當程式執行時會先產生全域執行環境，</p><p>在逐行執行時如果呼叫了其他的函式便會停止執行程式並創造另一個執行環境，</p><p>每個函式都會創建一個執行環境，且經歷創造階段並逐行執行程式。</p><p>函式結束後就會離開(pop)執行堆，</p><p>而程式碼實際的排列順序並不重要，</p><p>在執行堆中最上面的就是正在執行的東西。</p><hr><p><strong>此系列爲線上課程：<a href="https://www.udemy.com/course/javascriptjs/" target="_blank" rel="noopener">JavaScript 全攻略：克服 JS 的奇怪部分</a>上課內容筆記</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> function </tag>
            
            <tag> Function Invocation </tag>
            
            <tag> Execution stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JS筆記] 單執行緒、同步執行</title>
      <link href="/JavaScript/2019/11/19/javascript-weird-4/"/>
      <url>/JavaScript/2019/11/19/javascript-weird-4/</url>
      
        <content type="html"><![CDATA[<h3 id="單執行緒"><a href="#單執行緒" class="headerlink" title="單執行緒"></a>單執行緒</h3><blockquote><p>單執行緒(single threaded):one command at a time</p></blockquote><p>單執行緒表示一次只執行一個指令，</p><p>JavaScript 一次只作一件事情。</p><h3 id="同步執行"><a href="#同步執行" class="headerlink" title="同步執行"></a>同步執行</h3><blockquote><p>同步執行(synchronous execution): one at a time and in order. 對程式語言來說一次一個且照順序</p></blockquote><p>而同步執行則表示對程式而言一次只執行一行且按照順序。</p><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>JavaScript是單執行緒且同步執行的， JavaScript一次只做一件事情。</p><p>關於JavaScript的非同步請求後續會再繼續討論。</p><hr><p><strong>此系列爲線上課程：<a href="https://www.udemy.com/course/javascriptjs/" target="_blank" rel="noopener">JavaScript 全攻略：克服 JS 的奇怪部分</a>上課內容筆記</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> single threaded </tag>
            
            <tag> synchronous execution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JS筆記] 執行環境:創造與提升</title>
      <link href="/JavaScript/2019/11/11/javascript-weird-3/"/>
      <url>/JavaScript/2019/11/11/javascript-weird-3/</url>
      
        <content type="html"><![CDATA[<h3 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h3><p>我們先來看一段程式碼:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"Hello wolrd!"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Called b!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">b();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>在這裏我們宣告了變數<code>a</code>及<code>function b</code>並執行function b且印出變數a，</p><p>我們可以預期印出的結果為:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Called b!</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>但如果在宣告之前先執行function b並印出變數a會得到什麼結果呢?</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"Hello wolrd!"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Called b!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分的程式會因為還沒宣告function b就已經執行上列程式碼而產生error，</p><p>但在JavaScript執行並不會產生error，</p><p>其執行結果會如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Called b!</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><p>而這個現象稱為<code>Hoisting(提升)</code>。</p><hr><p>在解釋Hoisting之前我們先來瞭解JavaScript的執行環境創造，</p><p>JavaScript的執行環境被分成兩階段創造，</p><h3 id="創造階段"><a href="#創造階段" class="headerlink" title="創造階段"></a>創造階段</h3><p>第一階段是<code>創造(creation)階段</code>，</p><p>在這個階段會創造全域物件和this變數在記憶體中以及創造外部環境。</p><p>當語法解析器開始執行程式碼時它會知道變數和函數在哪裡創造，</p><p>在逐行執行程式之前JavaScript會為變數在記憶體中建立一個空間，</p><p>所以變數和函式已經存在於記憶體當中，</p><p>因此當程式逐行執行時就可以找到他們。</p><blockquote><p>Hoisting : Setup Memory Space for variables and functions</p></blockquote><p>但函式和變數又有些不同，</p><p>在第一階段函式已經全部放入記憶體中，</p><p>代表它的內容已經被執行，</p><p>但JavaScript為變數預留記憶體位置時並不知道他的值是多少，</p><p>因此給予<code>undefined</code>這個特殊值，</p><p>所有JavaScript的變數一開始都被設定為undefined。</p><blockquote><p>undefined : JavaScript內建的特殊值(special keyword)這跟從未宣告變數不同。</p></blockquote><p>永遠不要將變數值設為undefined，</p><p>在除錯時你會搞不清楚是自己設定為undefined或JavaScript設定為undefined，</p><p>讓undefined表示”我從未設定這個值”。</p><h3 id="執行階段"><a href="#執行階段" class="headerlink" title="執行階段"></a>執行階段</h3><p>而第二階段為執行階段，</p><p>在此階段程式碼將會被逐行執行。</p><p>這時候變數的值就會被放入記憶體中。</p><p>-</p><p>這就是為什麼我們可以在函式宣告前呼叫他，</p><p>在變數宣告前會拿到<code>undefined</code>的原因了。</p><hr><p><strong>此系列爲線上課程：<a href="https://www.udemy.com/course/javascriptjs/" target="_blank" rel="noopener">JavaScript 全攻略：克服 JS 的奇怪部分</a>上課內容筆記</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> hoisting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JS筆記] 全域環境與全域物件</title>
      <link href="/JavaScript/2019/11/05/javascript-weird-2/"/>
      <url>/JavaScript/2019/11/05/javascript-weird-2/</url>
      
        <content type="html"><![CDATA[<p>這一篇會討論JavaScript的全域執行環境<br>以及全域執行環境裡兩個特別的東西全域物件及this</p><a id="more"></a><h3 id="全域執行環境"><a href="#全域執行環境" class="headerlink" title="全域執行環境"></a>全域執行環境</h3><p>不論何時執行JavaScript程式，它都在執行環境裡面執行，</p><p>基礎的執行環境(basic execution context)就是指全域執行環境，</p><p>而全域執行環境會創造兩個東西: <code>全域物件(global object)</code>和<code>this</code>。</p><img src="/JavaScript/2019/11/05/javascript-weird-2/execution-context.png"><p>執行JavaScript時永遠會有一個全域物件，</p><p>例如用瀏覽器執行JavaScript時會有一個window object代表瀏覽器的全域物件，</p><p>一個視窗會有一個全域物件，</p><p>所以開啟另一個分頁會有另一個全域物件，</p><p>每個視窗都有自己的執行環境和自己的全域物件，</p><p>在執行環境中JavaScript會自動創造一個變數<code>this</code>，</p><p>當JavaScript的引擎創造執行環境的時候它也會決定this是什麼，</p><p>在全域等級中的this等於<code>全域物件(Global Object)</code>，</p><p>所以在瀏覽器裡的this會是window物件，</p><p>但如果在Nodejs的伺服器上<code>this</code>就不會是window物件，</p><p>全域物件只有在全域執行環境中，</p><p>但this永遠在執行環境裡，</p><p>關於this之後還會有更多的深入了解。</p><h3 id="全域"><a href="#全域" class="headerlink" title="全域"></a>全域</h3><blockquote><p>Global : Not inside a function</p></blockquote><blockquote><p>對JavaScript而言，不在function裡的就是全域(Global)</p></blockquote><p>全域的意思就是代表不論我們在任何地方都可以取用它,</p><p>在JavaScirpt裡只要不在函式裡(function)就是全域，</p><p>當在全域等級執行就代表沒有外部環境，</p><p>因為已經在最外面了。</p><hr><p><strong>此系列爲線上課程：<a href="https://www.udemy.com/course/javascriptjs/" target="_blank" rel="noopener">JavaScript 全攻略：克服 JS 的奇怪部分</a>上課內容筆記</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> execution context </tag>
            
            <tag> global object </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ES6] 展開運算子(spread operator)與其餘運算子(rest operator)</title>
      <link href="/uncategorized/2019/10/20/es6-spread-operator/"/>
      <url>/uncategorized/2019/10/20/es6-spread-operator/</url>
      
        <content type="html"><![CDATA[<p>展開運算子和其餘運算子是ES6的新特性，<br>都是使用三個點 <code>...</code>的符號</p><a id="more"></a><h3 id="展開運算子-Spread-Operator"><a href="#展開運算子-Spread-Operator" class="headerlink" title="展開運算子(Spread Operator)"></a>展開運算子(Spread Operator)</h3><p>展開運算子的作用為將陣列展開成個別值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr) <span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>展開運算子也可以拿來組合陣列取代<code>concat()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr2 = [<span class="string">'A'</span>, <span class="string">'B'</span>, ...arr] <span class="comment">// ['A', 'B', 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>或是運用於陣列的拷貝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr2 = [...arr] <span class="comment">// [1, 2, ,3 , 4, 5]</span></span><br></pre></td></tr></table></figure><p>展開運算子也可以把可迭代(iterable)及陣列相似(Array-like)的物件轉成陣列</p><ul><li>可迭代物件： String, Array, Map, Set物件</li><li>陣列相似： arguments</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'helloworld'</span></span><br><span class="line"><span class="keyword">const</span> chars = [...str] <span class="comment">// [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]</span></span><br></pre></td></tr></table></figure><h3 id="其餘運算子-rest-Operator"><a href="#其餘運算子-rest-Operator" class="headerlink" title="其餘運算子(rest Operator)"></a>其餘運算子(rest Operator)</h3><p>其餘運算子有兩個運用的地方，<br>一個是在函式傳入參數定義的地方，<br>另一個是解構賦值。</p><h4 id="其餘參數"><a href="#其餘參數" class="headerlink" title="其餘參數"></a>其餘參數</h4><p>當我們想要傳入不確定數量的參數到函式時，<br>就可以使用其餘運算子達到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">...nums</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">//6</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>傳入的參數會被轉成陣列，<br>一個函式只能有一個其餘參數，且只能放在最後面，<br>如果沒有傳入則它的值會是空陣列<code>[]</code>。<br>使用其餘參數取代<code>arguments</code>，<br>因為<code>arguments</code>是類陣列而非真正的陣列，<br>可能會造成非預期的錯誤。</p><h4 id="解構賦值-destructuring"><a href="#解構賦值-destructuring" class="headerlink" title="解構賦值(destructuring)"></a>解構賦值(destructuring)</h4><p>解構賦值也是ES6的新特性，<br>使用解構賦值可以將陣列裡的資料取出成獨立變數。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>其用法跟其餘參數類似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, ...c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">//[3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>如果沒有給值一樣會得到空陣列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, ..c] = [<span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">//[]</span></span><br></pre></td></tr></table></figure><h4 id="建議撰寫風格"><a href="#建議撰寫風格" class="headerlink" title="建議撰寫風格"></a>建議撰寫風格</h4><ul><li>使用其餘運算子代替函式裡的<code>arguments</code></li><li>在其餘運算子及展開運算子後面緊接著識別名稱，不要加入空白</li><li>使用展開運算子拷貝陣列</li><li>使用展開運算子取代<code>concat</code>和<code>slice</code></li></ul><p><strong>參考資料</strong></p><ol><li><a href="https://pjchender.blogspot.com/2017/01/es6-spread-operatorrest-operator.html" target="_blank" rel="noopener">[筆記] JavaScript ES6 中的展開運算子（spread operator）和其餘運算子（rest operator）</a></li><li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/rest_spread.html" target="_blank" rel="noopener">展開運算符與其餘運算符</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> spread operator </tag>
            
            <tag> rest operator </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Data Structure] Linked List (連結串列)</title>
      <link href="/data-structure/2019/10/20/linked-list/"/>
      <url>/data-structure/2019/10/20/linked-list/</url>
      
        <content type="html"><![CDATA[<h3 id="Linked-List-連結串列"><a href="#Linked-List-連結串列" class="headerlink" title="Linked List (連結串列)"></a>Linked List (連結串列)</h3><p>Linked list是一種常見的資料結構，<br>由很多node(節點)組成。<br>每個節點會儲存資料以及指向下一個節點的位置，<br>而最後一個節點則指向null，<br>因此Linked list可以使用不連續的記憶體空間來紀錄資料。</p><img src="/data-structure/2019/10/20/linked-list/linkedlist.png"><a id="more"></a><p>但因為Linked list沒有索引值，<br>當我們要搜尋某個節點時就必須從第一個node開始往後找，<br>因此搜尋的時間複雜度是O(N)，<br>知道位置之後插入/刪除資料只需要改變其指向的記憶體位置，<br>其時間複雜度是O(1)。</p><p><strong>優點</strong></p><ol><li>新增刪除較陣列容易只需要調整node裡指向的記憶體位置</li><li>不需要事先給定大小，可以動態調整其大小</li></ol><p><strong>缺點</strong></p><ol><li>需要使用額外的記憶體紀錄下一個指向的記憶體位置</li><li>因為沒有索引值，想要找到某個節點就逐一訪問每一個節點</li></ol><h3 id="使用JavaScript實做linked-list"><a href="#使用JavaScript實做linked-list" class="headerlink" title="使用JavaScript實做linked list"></a>使用JavaScript實做linked list</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this class represents each single node</span></span><br><span class="line"><span class="comment">// this class is extremely simple and just models the node</span></span><br><span class="line"><span class="comment">// this class DOES NOT have methods in it</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data, next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data</span><br><span class="line">        <span class="keyword">this</span>.next = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// this class represents an entire list of nodes</span></span><br><span class="line"><span class="comment">// this class has a property "root" that represents</span></span><br><span class="line"><span class="comment">// only the first node in the list</span></span><br><span class="line"><span class="comment">// this class has methods that operate over the entire list from just the root</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // add a value to the front of the list</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.root === <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the size of the list</span></span><br><span class="line">    prepend(data) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> ListNode(data)</span><br><span class="line">        node.next = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="keyword">this</span>.root = node</span><br><span class="line">        <span class="keyword">this</span>.size ++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    append(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addAtIndex(<span class="keyword">this</span>.size - <span class="number">1</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns a string representing the list</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="keyword">let</span> result = <span class="string">'root -&gt; '</span></span><br><span class="line">        <span class="keyword">while</span>(current !== <span class="literal">null</span>) &#123;</span><br><span class="line">            result += current.data + <span class="string">' -&gt; '</span></span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        result += <span class="string">'null'</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    length() &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(current !== <span class="literal">null</span>) &#123;</span><br><span class="line">            count ++</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>(index) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(current !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count === index) &#123;</span><br><span class="line">                <span class="keyword">return</span> current.data</span><br><span class="line">            &#125;</span><br><span class="line">            count ++</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    addAtIndex(index, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prepend(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> current = <span class="keyword">this</span>.root</span><br><span class="line">          <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span>(current !== <span class="literal">null</span> &amp;&amp; i &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">            i++</span><br><span class="line">            current = current.next</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> node = <span class="keyword">new</span> ListNode(value)</span><br><span class="line">          node.next = current.next</span><br><span class="line">          current.next = node</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.size ++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    removeAtIndex(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.removeFront()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.removeRest(index)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.size --</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    removeFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">this</span>.root.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    removeRest(index) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(current !== <span class="literal">null</span> &amp;&amp; count &lt; index <span class="number">-1</span> ) &#123;</span><br><span class="line">            count ++</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = current.next.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>課程筆記</strong>:<br><a href="https://www.udemy.com/course/javascript-datastructures/" target="_blank" rel="noopener">Data Structures in JavaScript: Master The Fundamentals</a></p>]]></content>
      
      
      <categories>
          
          <category> data structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> data structure </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[GIT] 設定SSH金鑰與Github連線</title>
      <link href="/git/2019/10/13/connect-github-using-ssh/"/>
      <url>/git/2019/10/13/connect-github-using-ssh/</url>
      
        <content type="html"><![CDATA[<p>跟github連線存取資料有兩種連線方式，分別是https和ssh，</p><p>使用https連線的話每次push都需要輸入帳號密碼，</p><p>如果使用ssh連線的話可以立刻上傳就不需要每次都輸入帳號密碼。</p><a id="more"></a><h3 id="SSH連線運作方式"><a href="#SSH連線運作方式" class="headerlink" title="SSH連線運作方式"></a>SSH連線運作方式</h3><img src="/git/2019/10/13/connect-github-using-ssh/ssh-connection-explained.png"><p style="text-align:right">    <a href="https://sebastien.saunier.me/blog/2015/05/10/github-public-key-authentication.html" target="_blank" rel="noopener">圖片來源:GitHub public key authentication</a> </p><ol><li>Client端送出SSH連線給Server</li><li>Server回傳隨機的訊息</li><li>Client端會使用私鑰進行加密</li><li>Client端再把加密後的訊息回傳至Server</li><li>Server使用公鑰解密</li><li>訊息相同表示驗證成功</li></ol><h3 id="產生金鑰"><a href="#產生金鑰" class="headerlink" title="產生金鑰"></a>產生金鑰</h3><p>使用下列指令產生金鑰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your email address&quot;</span><br><span class="line"></span><br><span class="line">-t: key的類型</span><br><span class="line">-b: 多少bits的key</span><br><span class="line">-C: 提供給key的註解也可以當作label，這裡我使用個人的電子信箱</span><br></pre></td></tr></table></figure><p>接著會詢問放置金鑰的位置</p><img src="/git/2019/10/13/connect-github-using-ssh/gen-ssh-key-1.png"><p>預設的位置會在/home/user/.ssh，</p><p>如果沒有要更改直接輸入enter跳過，</p><p>接著會要求輸入密碼，</p><p>如果沒有要設定密碼也可以直接輸入enter跳過，</p><p>接著金鑰就產生完成可以在.ssh目錄下看到id_rsa及id_rsa_pub。</p><h3 id="設定金鑰代理"><a href="#設定金鑰代理" class="headerlink" title="設定金鑰代理"></a>設定金鑰代理</h3><p>先使用下列指令開啟SSH代理伺服器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure><p>接著將我們剛剛產生的金鑰加入到SSH代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>最後我們要將剛剛產生的金鑰放在github上，</p><p>登入github上之後找到setting&gt;SSH and GPG keys，</p><img src="/git/2019/10/13/connect-github-using-ssh/github-ssh.png"><p>選擇New SSH Key</p><p>title的部份可以自行填寫方便記憶這是哪一台電腦的key的名稱，例如：work Laptop</p><p>key的部份要把剛剛產生的公鑰複製貼上，</p><p>儲存之後就完成設定，</p><p>之後使用git push就可以使用ssh 連線不用輸入密碼，</p><p>可以使用下列指令測試是否可以順利連線。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="備註"><a href="#備註" class="headerlink" title="備註"></a>備註</h3><p>設定完SSH金鑰連線至github就不需要輸入密碼，</p><p>如果設定完之後仍然被要求輸入帳號密碼，</p><p>可以檢查是否使用到https連線而非ssh連線，</p><p>使用 <code>git remote -v</code> 確認，</p><p>接著可以使用下面的指令更改成ssh連線：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:USERNAME/OTHERREPOSITORY.git</span><br></pre></td></tr></table></figure><p><strong>參考資料</strong>:<br>1.<a href="https://gist.github.com/fokayx/255b228ded2bca1c4f60" target="_blank" rel="noopener">Git 更換遠端伺服器倉庫網址URL</a><br>2.<a href="https://andy6804tw.github.io/2018/03/22/github-ssh/#2-%E8%A8%AD%E5%AE%9A%E9%87%91%E9%91%B0%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">使用 SSH 金鑰與 GitHub 連線</a><br>3.<a href="http://henrick168-blog.logdown.com/posts/736708-git-set-up-ssh-settings" target="_blank" rel="noopener">[Git] 建立 ssh 設定</a><br>4.<a href="https://sebastien.saunier.me/blog/2015/05/10/github-public-key-authentication.html" target="_blank" rel="noopener">GitHub public key authentication</a><br>5.<a href="https://git-scm.com/book/zh-tw/v1/%E4%BC%BA%E6%9C%8D%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0" target="_blank" rel="noopener">伺服器上的 Git - 生成 SSH 公開金鑰</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JS筆記] 語法解析器、執行環境與詞彙環境</title>
      <link href="/JavaScript/2019/09/18/javascript-weird-1/"/>
      <url>/JavaScript/2019/09/18/javascript-weird-1/</url>
      
        <content type="html"><![CDATA[<p>第一篇先記錄一些關於JavaScript的名詞解釋,</p><p>之後會不斷的遇到這些觀念,</p><p>這些名詞聽起來好像很複雜其實都不難懂,</p><p>因此我們先來瞭解這些名詞的意義吧！</p><a id="more"></a><h3 id="syntax-parser-語法解析器"><a href="#syntax-parser-語法解析器" class="headerlink" title="syntax parser(語法解析器)"></a>syntax parser(語法解析器)</h3><blockquote><p>A program that reads your code and determines what it does and if its grammar is valid.<br>語法解析器：指直譯器或編譯器，將你所寫的程式轉換成電腦能懂得語言。</p></blockquote><p>我們所寫的程式碼並不能直接告訴電腦該做什麼,</p><p>當我們寫了程式碼之後會透過別人所寫的另一個程式,</p><p>將我們所寫的程式電腦可以執行的指令,</p><p>而把我們的程式轉換成電腦可以懂的東西就是編譯器或直譯器,</p><p>也就是語法解析器。</p><hr><h3 id="Lexical-environments-詞彙環境"><a href="#Lexical-environments-詞彙環境" class="headerlink" title="Lexical environments(詞彙環境)"></a>Lexical environments(詞彙環境)</h3><blockquote><p>where somethings sits physically in the code you write.</p></blockquote><p>詞彙環境聽起來很複雜，</p><p>其實詞彙環境就是指程式碼的實際位置，</p><p>他被寫在哪?他的周圍環境是什麼?</p><p>對有些程式語言來說程式碼寫在哪很重要，</p><p>但不是每個程式語言都是，</p><p>而對JavaScript而言詞彙環境是重要的，</p><p>因為他的位置可以幫助語法解析器做決定。</p><hr><h3 id="Execution-contexts-執行環境"><a href="#Execution-contexts-執行環境" class="headerlink" title="Execution contexts(執行環境)"></a>Execution contexts(執行環境)</h3><blockquote><p>a wrapper to help manage the code that is running.</p></blockquote><p>執行環境管理正在執行的程式碼，</p><p>但裡面不只包含我們所寫的程式碼，</p><p>還有其他的東西以後會陸續的提到。</p><hr><h3 id="Name-value-pair-名稱-值配對"><a href="#Name-value-pair-名稱-值配對" class="headerlink" title="Name/value pair(名稱/值配對)"></a>Name/value pair(名稱/值配對)</h3><blockquote><p>a name which maps to a unique value.</p></blockquote><p>名稱可能會被定義很多次，但在給定一種情狀下它只能有一個值，</p><p>在任何一個執行環境中(一段正在執行的程式碼)，</p><p>同樣名稱只有一個，而這個名稱只能被一個值定義。</p><p>但這個值可以是另一個名稱/值的配對。</p><p>舉例來說：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Apartment: &#123;</span><br><span class="line">    floor: <span class="number">3</span>,</span><br><span class="line">    num: <span class="number">301</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Apartment</code>是名稱，</p><p>但他的值是更多的名稱/值配對的組合，</p><p>裡面的<code>floor</code>是另一個名稱對應值爲3，</p><p>以及名稱<code>num</code>對應值爲301。</p><hr><h3 id="Object-物件"><a href="#Object-物件" class="headerlink" title="Object(物件)"></a>Object(物件)</h3><blockquote><p>a collection of name value pairs</p></blockquote><p>而JavaScript的物件最簡單的定義就是名稱/值配對的組合，</p><p>如同我們上面的例子<code>Apartment</code>就是一個物件，</p><p>在其他的程式語言裡面物件或許有更複雜的定義，</p><p>但在JavaScript裡，物件的定義就只有這樣。</p><hr><p><strong>此系列爲線上課程：<a href="https://www.udemy.com/course/javascriptjs/" target="_blank" rel="noopener">JavaScript 全攻略：克服 JS 的奇怪部分</a>上課內容筆記</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> object </tag>
            
            <tag> syntax parser </tag>
            
            <tag> lexical environments </tag>
            
            <tag> execution contexts </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
